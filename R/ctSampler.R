##' Blocked Gibbs Sampler of Cell Type Parameters##'##' ##' The cell types are sampler from the model described elsewhere.##' There will be /code{(nkeep * nthin +nburn) nchain} samples drawn##' and /code{nkeep * nchain} will be retained. ##' ##' @title Cell Type Sampler##' @param gMat integer matrix of cell type counts with rows for##'   clones and columns for cell types.##' @param uop numeric matrix such that /code{uop} has rows that sum to 1.0 or less##' @param piInit a vector of /code{nrow(uop)} proportions summing to##'     1 or an expression object that evaluates to such.##' @param nkeep how many samples to keep in each chain##' @param nthin how many smaples to generate for each sample kept##' @param nburn how many initial samples to discard before keping a##'   sample##' @param nchain how many chains to create##' @param ncores if 2 or more use parallel processing##' @return matrix of expected cell type frequencies with##'   /code{nrow(uop)} rows and /code{nkeep} columns.##' @author Charles Berry##' @import parallel##' @useDynLib cellTypeCompositions, .registration=TRUE##' @importFrom Rcpp evalCpp##' @export##' @examples##' mat <- t( rmultinom(10,size=100,p=rep(.2,5)))##' errmat <- prop.table( diag(5) + .02, 1)/2##' res <- ctSampler( mat, errmat, rep(0.2, 5),100)##' ## A small value is expected##' all.equal( t(errmat %*% sapply(res, rowMeans)), mat)ctSampler <-    function(gMat, uop, piInit, nkeep, nthin=1L, nburn=0L, nchain=1L,             ncores=1L){        mc <- match.call()        ## do 1 row of gMat        samplePI1 <- function(g,u,p,nk,nt,nb,nch){            val <- list()            for (ich in 1:nch){                                p <- eval(p)                lenpi <- length(p)                if (length(p)!=nruop) stop("length(piInit) and nrow(uop) don't match")                val[[ich]] <- samplePI(g,u,p,nk,nt,nb)            }            do.call(cbind,val)        }                nruop <- nrow(uop)        ncuop <- ncol(uop)                    if (!is.matrix(gMat))            dim(gMat) <- c(1, length(gMat))        nrg <- nrow(gMat)        ncg <- ncol(gMat)        if (ncg != ncuop)            stop("ncol(gMat) does not equal ncol(uop)")        res  <- mclapply(1:nrg,                       function(i) samplePI1(gMat[i,],uop,                                             piInit,nkeep,                                             nthin,nburn,nchain),                       mc.cores = ncores, mc.set.seed = TRUE)        attr(res,"call") <- mc        res    }