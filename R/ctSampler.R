##' Blocked Gibbs Sampler of Cell Type Parameters##'##' ##' The cell types are sampled from the model described elsewhere##' using a symmetric Dirichlet prior. By default, the \dQuote{flat}##' Dirichlet distribution is used.  There will be /code{(nkeep *##' nthin +nburn) nchain} samples drawn and /code{nkeep * nchain} will##' be retained.##' ##' @title Cell Type Sampler##' @param gMat integer matrix of cell type counts with rows for##'     clones and columns for cell types.##' @param uop numeric matrix such that \code{uop} has rows that sum##'     to 1.0 or less##' @param piInit a vector of \code{nrow(uop)} proportions summing to##'     1, an expression object that evaluates to such or a matrix##'     with \code{nrow(uop)} rows and \code{nrow(gMat)} columns.##' @param nkeep how many samples to keep in each chain##' @param nthin how many samples to generate for each sample kept##' @param nburn how many initial samples to discard before keping a##'     sample##' @param nchain how many chains to create##' @param dprior Dirichlet prior parameter##' @param ncores if 2 or more use parallel processing##' @param method \dQuote{sampleX} with do proper Gibbs sampling (the##'     default). The \dQuote{sample_via_EX} will use the expected##'     value of the unobserved cell types rather than drawing a##'     sample.##' @return a list of class \code{"symmetricPrior"} whose canonical##'     element is a matrix of expected cell type frequencies with##'     \code{nrow(uop)} rows and \code{nkeep} columns.##' @author Charles Berry##' @import parallel##' @useDynLib cellTypeCompositions, .registration=TRUE##' @importFrom Rcpp evalCpp##' @export##' @include RcppExports.R##' ##' @examples##' mat <- t( rmultinom(10,size=100,p=rep(.2,5)))##' errmat <- prop.table( diag(5) + .02, 1)/2##' res <- ctSampler( mat, errmat, rep(0.2, 5),100)##' ## A small value is expected##' all.equal( t(errmat %*% sapply(res, rowMeans)), mat)ctSampler <-    function(gMat, uop, piInit, nkeep, nthin=1L, nburn=0L, nchain=1L,             dprior = 1.0, ncores=1L,method=c("sampleX","expectX")){	mc <- match.call()        stopifnot( !is.matrix(piInit) || ncol(piInit) == nrow(gMat),                  !is.matrix(piInit) || nrow(piInit) == nrow(uop))        method <- match.arg(method)        methodFUN <-            switch(method,                   sampleX = samplePI,                   expectX = samplePI_via_EX)	## do 1 row of gMat	samplePI1 <- function(g,u,p,nk,nt,nb,nch,dpr){	    val <- list()	    for (ich in 1:nch){                		p <- eval(p)		lenpi <- length(p)		if (length(p)!=nruop) stop("length(piInit) and nrow(uop) don't match")		val[[ich]] <- methodFUN(g,u,p,nk,nt,nb,dpr)	    }	    do.call(cbind,val)	}	nruop <- nrow(uop)	ncuop <- ncol(uop)	if (!is.matrix(gMat))	    dim(gMat) <- c(1, length(gMat))	nrg <- nrow(gMat)	ncg <- ncol(gMat)	if (ncg != ncuop)	  stop("ncol(gMat) does not equal ncol(uop)")	piMatFun <-	  function(i) samplePI1(gMat[i,],uop,				piInit[, i],nkeep,				nthin,nburn,nchain, dprior)	piVecOrExprFun  <- 	  function(i) samplePI1(gMat[i,],uop,				piInit,nkeep,				nthin,nburn,nchain, dprior)	sampleCall <-	  if (is.matrix(piInit)) piMatFun else piVecOrExprFun	res  <- mclapply(1:nrg,sampleCall,		       mc.cores = ncores, mc.set.seed = TRUE)	attr(res,"call") <- mc        class <- "symmetricPrior"	res    }samplePI_via_EX <-    function(gi, om, pi0, nkeep, nthin = 1L, nburn = 0L, dprior = 1.0){        nsamps  <-  (nkeep - 1L) * nthin + nburn + 1L        isamp  <- 0L        rwom <- rowSums(om)        r <- sum(gi)        gammat  <- matrix(0.0, nrow = nrow(om), ncol = nkeep)        for (i in 1:nsamps){            rho_obs <- sum(pi0 * rwom)            R_minus_r <- r*(1-rho_obs)/rho_obs            pi_miss <- pi0 * (1 - rwom ) / (1-rho_obs)            dropped_f <- R_minus_r * pi_miss            pi_given_gi <- prop.table( as.vector( pi0 ) * om , 2)            shuffled_f <- pi_given_gi %*% gi            dirichlet_parm <- dprior + shuffled_f + dropped_f            gamma_vals <- rgamma(dirichlet_parm, dirichlet_parm)            pi0 <- prop.table( gamma_vals)            if ( (i > nburn) && ((i-nburn-1L)%%nthin == 0L))                gammat[ , (isamp <- isamp + 1L)] <-                    pi0 * rgamma(1L,R_minus_r + r )        }        gammat    }