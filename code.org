

# source code for the package

* headers

#+name: arma-headers
#+begin_src cpp

  #include <RcppArmadillo.h>
  using namespace Rcpp;
  using namespace arma;
  // [[Rcpp::depends(RcppArmadillo)]]


#+end_src


* utils

#+name: logprob_Rplus
#+begin_src cpp


  // log probability of r given p and lambda

  // log likelihood kernel sans constants in data r1!, r2!, ...
  double llkr( int rsum, int n, double p, double lambda ){
    double llk;
    if (ISNA(lambda)) {
      llk = 0.0;
    }
    else
      {
	if (lambda<DOUBLE_XMIN) lambda = DOUBLE_XMIN;
	llk = (double) rsum * (log(lambda)+log(p)) -
	  (double) n*(lambda*p + log1p(-exp(-lambda*p)));
      }
    return llk;
  }

  // lambda vectorized log probability of r given p and lambda

  arma::rowvec logprob_p( int r, double p, arma::rowvec lambda ){
    rowvec result(lambda.size());
    for (int i = 0L; i<lambda.size(); i++) 
      result[i] = llkr( r, 1L, p, lambda[i] );
    return result;
  }    

  // p vectorized log probability of r given p and lambda

   arma::rowvec logprob_l( int r, arma::rowvec p,  double lambda ){
    rowvec result(p.size());
    for (int i = 0L; i<p.size(); i++) 
      result[i] = llkr( r, 1L, p[i], lambda );
    return result;
  }    

#+end_src

#+name: logprobMulti
#+begin_src cpp

  // log probability vector (sans multinomial coefficient)

  inline arma::rowvec logprob(arma::irowvec& tabrow, arma::mat& om,
			      arma::mat& eta, arma::rowvec& etaN,
			      int etaLast, double lambda){
    rowvec logpr(etaLast);
    int J = eta.n_rows;
    int K = om.n_cols;
    for (int rc = 0; rc<etaLast; rc++){
      double rhosum = 0.0;
      int tabsum = 0L;
      double logprc = 0.0;

      for (int k = 0; k<K; k++){
	tabsum+=tabrow(k);
	double rhoelt = 0.0;
	for (int j=0;j<J;j++) rhoelt+=om(j,k)*eta(j,rc);
	logprc+= tabrow(k) * log(rhoelt);
	rhosum+= rhoelt;
      }
      logprc-= (double) tabsum * log(rhosum);
      logprc+= llkr( tabsum, 1L, rhosum, lambda );
      logprc+= log( etaN(rc));
      logpr(rc) = logprc;
    }
    return logpr;
  }

#+end_src

#+name: rdirich
#+begin_src cpp
  // uniform dirichlet random numbers

  inline vec rdirich( int n, double dprior=1.0 ){
    vec rg( n );
    for (int i = 0; i<n; i++) {
      rg(i)=Rf_rgamma(dprior, 1.0);
    }
    return rg/sum(rg);
  }

#+end_src

#+name: newIndex
#+begin_src cpp

  // sample one index
  int newIndex(arma::rowvec logpr){
    double maxlogpr = max(logpr);
    double prcum = 0.0;
    for (int i =0;i<logpr.size(); i++){
      prcum += exp(logpr(i)-maxlogpr);
      logpr(i) = prcum;
    }  
    double ur = Rf_runif(0.0,prcum);
    int index=0L;
    for (; logpr[index] < ur && index<logpr.size(); index++);
    return index;
  }

#+end_src

#+name: rlamGivenR
#+begin_src cpp

  #define KMAX 1000L

  int newIndex(arma::rowvec logpr);

  // [[Rcpp::export]]
  double rlamGivenR(double rho,double alpha,double beta,int r){

    arma::rowvec lkp(KMAX);
    for (int k = 0; k<KMAX; k++) lkp[k] = -(r+alpha)*log(beta+rho*(1.0+k));

    int indx = newIndex(lkp);

    double rg = Rf_rgamma( alpha+r, 1.0/(beta+rho*(1+indx)));

    return rg;

  }

#+end_src

#+name: updateXX
#+begin_src cpp
  /*
    update a matrix and associated N vector in place
    Author: Charles C. Berry
    Date: 12-04-2020

  ,*/

  #define MORESIZE 10L
  #define MAXSIZE 100L


  int updateXX( int newind,
		 int i,
		 arma::mat& XX,
		 arma::rowvec& XXN,
		 arma::ivec& diToXX,
		 double XXN1,	// singleton flag
		 int& XXM,
		 int& decXXN,  
		 int& incXXNnew,
		 int& incXXNold,
		 int auxXXM,
		 int verbose)
  {

    int ndat = diToXX.n_elem;
    int di2XX = diToXX[ i ];
    int XXSize = XX.n_cols;

    if (XXN1){
      //singleton case
      if (verbose>2L) Rprintf("singleton\n");
      if (newind == di2XX)
	{
	  // retain di2XX
	  XXN( di2XX ) = 1;
	}
      else if (newind < XXM)
	{
	  // use existing element in place of this one and move di2e
	  XXN( newind )++;
	  diToXX( i ) = newind;
	  // shift left
	  XXN.shed_col(di2XX);
	  XX.shed_col(di2XX);
	  if (verbose>2L)
	    Rprintf("XXN.n_cols=%d XX.n_cols=%d\n", XXN.n_cols, XX.n_cols);
	  XXM--;
	  XXSize--;
	  decXXN++;
	  for (int idi=0; idi<ndat; idi++) 
	    if (diToXX[ idi ] >= di2XX) diToXX[ idi ]--;
	  if (verbose > 2L) Rprintf("diToXX=%d\n",diToXX[ i ]);
	}
      else
	{
	  // use new element
	  // copy to di2XX
	  XXN( di2XX ) = 1; incXXNnew++;
	  XX.col( di2XX ) = XX.col( newind );
	} 
    }
    else
      // initial run or XXN[ di2XX ] >= 2
      {
	if (verbose>2L) Rprintf("initial run or N>=2\n");
	if (newind >= XXM)
	  {
	    //use new element
	    XXN( XXM ) =1;
	    if (newind>XXM) XX.col(XXM) = XX.col(newind);
	    if (verbose>2L) Rprintf("XX(0,XXM)=%f\n", XX(0,XXM));
	    diToXX( i ) = XXM;
	    XXM++;
	    incXXNnew++;
	    if (verbose>2L) Rprintf("XXM=%d\n", XXM);
	  }
	else
	  {
	    // use existing element
	    XXN( newind )++;
	    diToXX( i ) = newind;
	    incXXNold++;
	  }

      }
    // check size and pad as needed
    if (XXM+auxXXM > XXSize){
      if (verbose) {
	Rprintf("XX has %d Elts ", XX.n_elem);
	Rprintf("XXSize = %d XXM = %d auxXXM = %d\n",
		XXSize, XXM, auxXXM);
      }
      int addSize = MORESIZE;
      if (XXSize + addSize <= MAXSIZE){
	XXSize += addSize;
	XX.resize( XX.n_rows, XXSize ); 
	XXN.resize( XXSize );
      } else {
	Rcpp::stop("Cannot resize XX");
      }
      if (verbose) Rprintf("XX has %d Elts\n", XX.n_elem);
    }
    return XXSize;
  }

#+end_src


#+name: rmultnm
#+begin_src cpp :noweb yes
  void rmultnm(int n, double* prob, int k, int* rn){
    double prsum = 0.0;
    for (int i=0; i<k; i++) prsum += prob[i];
    for (int i=0; i<k; i++) prob[i] /= prsum;
    Rf_rmultinom(n, prob,k,rn);
  }

#+end_src

* auxGibbs

#+name: auxGibbs
#+begin_src cpp
  /*
    auxGibbs.cpp

    Auxiliary Gibbs Sampler for negative multinomial sampler of cell
    type proportions.

    Author: Charles C. Berry
    Date: 24-01-2020
    10-01-2020
    22-04-2019
    16-060-2019
  ,*/

  /* assume
     imat tab = wtab["tab"];
     ivec di = wtab["data.index"];
     di = di - 1L;
     di, dataTo[Eta|Lambda] are zero based
  ,*/

  // [[Rcpp::export]]
  List auxGibbs(arma::imat& tab, arma::ivec& di, arma::mat& om, 
		arma::mat eta,
		arma::rowvec etaN,
		arma::ivec diToEta,
		arma::rowvec lambda,
		arma::rowvec lambdaN,
		arma::ivec diToLambda,
		int etaM = 0L,
		int auxM = 5L, double alpha = 100.0,
		int lambdaM = 0L,
		int auxLambdaM = 5L, double alphaLambda = 5.0,
		int ijvals = 0L,
		int verbose = 0L,
		double dprior=1.0,
		double lambdaShape=1.0,
		double lambdaRate=0.01) {
    // we get a list from R
    // pull std::vector<double> from R list
    // this is achieved through an implicit
    // call to Rcpp::as
  
    int etaCols = eta.n_cols;
    int lambdaSize = lambda.size();
    int J = om.n_rows;
    int ndat = di.size();
    int decN = 0L;
    int incNnew = 0L;
    int incNold = 0L;

    int decLambdaN = 0L;
    int incLambdaNnew = 0L;
    int incLambdaNold = 0L;

    for (int i=ijvals;
	 i<ndat && etaM+auxM <= etaCols && lambdaM+auxLambdaM <= lambdaSize;
	 i++){
  
      if (verbose>1L) Rprintf("i = %d\n",i);
    
      int di2e = diToEta[ i ];
      double etaN1; // singletons need one less 
      if (di2e >= 0L && etaN( di2e ) == 1.0){
	etaN1 = 1;
	etaN( di2e ) = alpha/auxM;
      }
      else
	{ etaN1 = 0; 
	  if (di2e>=0L) etaN( di2e )--;
	}
    
      int di2lam = diToLambda[ i ];
      double lambdaN1; // singletons need one less 
      if (di2lam >= 0L && lambdaN( di2lam ) == 1.0){
	lambdaN1 = 1.0;
	lambdaN( di2lam ) = alphaLambda/auxLambdaM;
      }
      else
	{ lambdaN1 = 0; 
	  if (di2lam>=0L) lambdaN( di2lam )--;
	}
    
      // sample auxM from prior
      for (int j = 0; j < auxM-etaN1; j++){
	eta.col(j + etaM ) = rdirich(J, dprior);
	etaN( j+etaM ) = alpha/auxM;
      }
    
      // rho and logprob
      // initially use lambdaVal = NA_REAL;
      double lambdaVal = (di2lam < 0 ) ? NA_REAL : lambda( di2lam );
    
      irowvec tr = tab.row(di( i ));
      int newind =
	newIndex(logprob( tr, om, eta, etaN,
			  etaM + auxM - (int) etaN1, lambdaVal));
    
      // update-eta
    
    
      etaCols = updateXX(  newind, i, eta, etaN, diToEta, etaN1, etaM,
		 decN, incNnew, incNold, auxM, verbose);
    
      // update-lambda
    
      // sample lambdaM from posterior
      double rhosum = (double) accu( trans(eta.col(newind))*om );
      int tabsum = arma::sum( tr );
      for (int j = 0; j < auxLambdaM-lambdaN1; j++){
	lambda(j + lambdaM ) =
	  rlamGivenR( rhosum, lambdaShape, lambdaRate, tabsum);
	lambdaN( j+lambdaM ) = alphaLambda/auxLambdaM;
      }
    
      newind = newIndex(logprob_p( tabsum, rhosum,
				   lambda.head(lambdaM+auxLambdaM) ) +
			log( lambdaN.head( lambdaM + auxLambdaM)));
    
      lambdaSize = updateXX(  newind, i, lambda, lambdaN, diToLambda, lambdaN1, lambdaM,
		 decLambdaN, incLambdaNnew, incLambdaNold, auxLambdaM, verbose);
    
    }
    if (verbose)  {
      Rprintf("delete Eta= %d add = %d use existing = %d ",
	      decN, incNnew, incNold);
      Rprintf("delete Lambda= %d add = %d use existing = %d\n",
	      decLambdaN, incLambdaNnew, incLambdaNold);
    }
    
    // return an R list; this is achieved
    // through an implicit call to Rcpp::wrap
    return List::create(_["eta"] = eta,
			_["etaN"] = etaN,
			_["dataToEta"] = diToEta,
			_["etaM"] = etaM,
			_["lambda"] = lambda,
			_["lambdaN"] = lambdaN,
			_["dataToLambda"] = diToLambda,
			_["lambdaM"] = lambdaM
			);
  }


#+end_src


* tests

Many src blocks can use Rcpp::sourceCpp(code="...").

However, strings with embedded backslash escapes will cause issues and
sometimes errors.

To obviate those, tangling to a temp file and using
Rcpp::sourceCpp("tempfilename.cpp") should work.

** rdirich

#+begin_src R :noweb yes
  Rcpp::sourceCpp(code='
  <<arma-headers>>
  <<rdirich>>
  // [[Rcpp::export]]
  vec call_rdirich( int n, double dprior=1.0 ){
  return rdirich( n, dprior );}
  ')

  ## test here
  set.seed(123)
  cr <- call_rdirich(5L,1.0)
  set.seed(123)
  rr <- prop.table(rgamma(5,1))

  if (all(cr==rr)) "PASS" else "FAIL"
#+end_src


** logprob_Rplus

#+begin_src R :noweb yes :session *R:cellTypeCompositions*
  Rcpp::sourceCpp(code='
  <<arma-headers>>
  <<logprob_Rplus>>
  // [[Rcpp::export]]
  double call_llkr( int rsum, int n, double p, double lambda ){
  return llkr( rsum, n, p,  lambda );}
  // [[Rcpp::export]]
  arma::rowvec call_logprob_p( int r, double p, arma::rowvec lambda ){
    return logprob_p(  r,  p,  lambda );}
  // [[Rcpp::export]]
  arma::rowvec call_logprob_l( int r, arma::rowvec p,  double lambda ){
  return logprob_l( r, p,  lambda );}
  ')

  ## test here

#+end_src

#+RESULTS:

#+begin_src R :noweb yes :session *R:cellTypeCompositions*

  R_llkr <- function(rsum, n, p, lambda){   
    lambda <- pmax(.Machine$double.xmin, lambda)
    res <-   rsum * (log(lambda)+log(p)) -
      n*(lambda*p + log1p(-exp(-lambda*p)))
    res[is.na(res)] <- 0.0
    res
  }

  cllkr <- call_logprob_p(3L,0.8,c(1.2,NA))
  rllkr <- R_llkr( 3L, 1L, 0.8, c(1.2,NA))

  if (all(cllkr == rllkr )) "PASS" else "FAIL"

  cllkr <- call_logprob_l(3L,c(0.8,0.9),1.2)
  rllkr <- R_llkr( 3L, 1L, c(0.8,0.9), 1.2)

  if (all(cllkr == rllkr )) "PASS" else "FAIL"

#+end_src

#+RESULTS:


** logprob_Multi

#+begin_src R :noweb yes :session *R:cellTypeCompositions*
  Rcpp::sourceCpp(code='
  <<arma-headers>>
  <<logprob_Rplus>>
  <<logprobMulti>>
  // [[Rcpp::export]]
  arma::rowvec call_logprob(arma::irowvec& tabrow, arma::mat& om,
  arma::mat& eta, arma::rowvec& etaN,
  int etaLast, double lambda){
  return logprob(tabrow, om, eta, etaN, etaLast, lambda);}
  ')
#+end_src

#+begin_src R :noweb yes :session *R:cellTypeCompositions*
  ## test here

  ## logprob(tabrow, om, eta, etaN, etaLast, lambda);}

  tabrow <- c(1,2,3)
  om<- (diag(3)+.05)/2
  eta <- prop.table(cbind(1:3,1,3:1),2)
  etaN <- 1:3
  etaLast <- 3
  lambda <- 2.0


  clp <- call_logprob(tabrow, om, eta, etaN, etaLast, lambda)

  Rlogprob <- function(tabrow, om, eta, etaN, etaLast, lambda){
    tabsum <- sum(tabrow)
    rho <- t( t(eta)%*%om )
    logprc <- tabrow %*% log(prop.table(rho,2)) +
      R_llkr(tabsum, 1L, colSums(rho), lambda) +
      log( etaN )
    logprc
  }

  Rlp <- Rlogprob(tabrow, om, eta, etaN, etaLast, lambda)

  if (isTRUE(all.equal(clp,Rlp))) "PASS" else "FAIL"
#+end_src

#+RESULTS:


** newIndex

#+begin_src R :noweb yes :session *R:cellTypeCompositions*
  Rcpp::sourceCpp(code='
  <<arma-headers>>
  <<newIndex>>
  // [[Rcpp::export]]
  int call_newIndex(arma::rowvec logpr){
    return newIndex(arma::rowvec logpr);}
  ')

  ## test here
#+end_src

** rlamGivenR

#+begin_src R :noweb yes :session *R:cellTypeCompositions*
  Rcpp::sourceCpp(code='
  <<arma-headers>>
  <<newIndex>>
  <<rlamGivenR>>
  // [[Rcpp::export]]
  double call_rlamGivenR(double rho,double alpha,double beta,int r){
  return rlamGivenR( rho, alpha, beta, r);}
  ')

  ## test here
#+end_src

#+RESULTS:

#+begin_src R :noweb yes :session *R:cellTypeCompositions*

  rlambdaGivenR <- function(rho, alpha, beta, r){
    KMAX <- 1000L
    lkp <-  -(r+alpha)*log(beta+rho*(1.0+0:KMAX));
    indx <- sample(0:KMAX,1,prob=exp(lkp))
    rgamma(1L, alpha+r, rate=(beta+rho*(1+indx)))
  }

  set.seed(1234)
  clam <- replicate(10, call_rlamGivenR(.8, 1.0,.01,1))
  set.seed(1234)
  rlam <- replicate(10,rlambdaGivenR(.8, 1.0,.01,1))

  all.equal(rlam,clam)
#+end_src


** updateXX


#+begin_src cpp :main no :noweb yes :tangle nobuild/test-updateXX.cpp
  <<arma-headers>>
  <<updateXX>>
  // [[Rcpp::export]]
  List call_updateXX( int newind, int i, List xlist){
    arma::mat XX = xlist["XX"];
    arma::rowvec XXN = xlist["XXN"];
    arma::ivec diToXX = xlist["diToXX"];
    double XXN1 = xlist["XXN1"];
    IntegerVector XXM = xlist["XXM"];
    IntegerVector decXXN = xlist["decXXN"];
    IntegerVector incXXNnew = xlist["incXXNnew"];
    IntegerVector incXXNold = xlist["incXXNold"];
    int auxXXM = xlist["auxXXM"];
    int verbose = xlist["verbose"];
    updateXX(newind, i, XX, XXN, diToXX, XXN1, XXM[0L],
	     decXXN[0L], incXXNnew[0L], incXXNold[0L], auxXXM, verbose);
    return List::create(
			_["XX"] = XX,
			_["XXN"] = XXN,
			_["diToXX"] = diToXX,
			_["XXN1"] = XXN1,
			_["XXM"] = XXM,
			_["decXXN"] = decXXN,
			_["incXXNnew"] = incXXNnew,
			_["incXXNold"] = incXXNold,
			_["auxXXM"] = auxXXM,
			_["verbose"] = verbose);
  }

#+end_src

#+begin_src R :noweb yes :session *R:cellTypeCompositions*
Rcpp::sourceCpp("nobuild/test-updateXX.cpp")
#+end_src

#+RESULTS:

#+begin_src R
  ## TODO: this exercises updateXX, but requires manual inspection of
  ## results to verify correctness

  xlist <- 
    list(
      i = 0L,
      XX = matrix(as.double(1:30),nrow=3),
      XXN = rep(0.0, 10),
      diToXX = rep(-1L,5),
      XXN1 = 0L,
      XXM = 0L,
      decXXN = 0L,
      incXXNnew = 0L,
      incXXNold = 0L,
      auxXXM = 5L,
      verbose = 3L
    )

  vlist <- 
    list(
      XX = matrix(as.double(1:10),nrow=1),
      XXN = rep(0.0, 10),
      diToXX = rep(-1L,5),
      XXN1 = 0L,
      XXM = 0L,
      decXXN = 0L,
      incXXNnew = 0L,
      incXXNold = 0L,
      auxXXM = 5L,
      verbose = 3L
    )


  ylist <- rlang::duplicate(xlist)

  ## choose 1
  zlist <- ylist

  zlist <- vlist

  ## cases  (4, 5, 4, 5, 4)  
  newinds <- c(4L,0L,5L,1L,6L)


  for (i in 0L:4L){
    zlist <- call_updateXX(newinds[i+1],i,zlist)
  }

  ## update singleton existing case 2 

  i  <- 4L
  d2x <- zlist$diToXX[ i + 1L ]
  zlist$XXN[ d2x+1L ] <-   zlist$XXN[ d2x+1L ] - 1.0
  zlist$XXN1  <- if (zlist$XXN[ d2x + 1L] == 0L) 1L else 0L
  zlist <- call_updateXX(0L,i,zlist)

  ## add new case 4

  i  <- 4L
  d2x <- zlist$diToXX[ i + 1L ]
  zlist$XXN[ d2x+1L ] <-   zlist$XXN[ d2x+1L ] - 1.0
  zlist$XXN1  <- if (zlist$XXN[ d2x + 1L] == 0L) 1L else 0L
  zlist <- call_updateXX(5L,i,zlist)

  ## revise in place case 1

  d2x <- zlist$diToXX[ i + 1L ]
  zlist$XXN[ d2x+1L ] <-   zlist$XXN[ d2x+1L ] - 1.0
  zlist$XXN1  <- if (zlist$XXN[ d2x + 1L] == 0L) 1L else 0L
  zlist <- call_updateXX(2L,i,zlist)

  ## remove early singleton case 2

  ni <- 1L
  for (i in 0:1){
    d2x <- zlist$diToXX[ i + 1L ]
    zlist$XXN[ d2x+1L ] <-   zlist$XXN[ d2x+1L ] - 1.0
    zlist$XXN1  <- if (zlist$XXN[ d2x + 1L] == 0L) 1L else 0L
    zlist <- call_updateXX(ni, i, zlist)
    }


  ## update singleton new case 3
  i <- 4L
  d2x <- zlist$diToXX[ i + 1L ]
  zlist$XXN[ d2x+1L ] <-   zlist$XXN[ d2x+1L ] - 1.0
  zlist$XXN1  <- if (zlist$XXN[ d2x + 1L] == 0L) 1L else 0L
  zlist <- call_updateXX(2L,i,zlist)



  ## test resizing

  i <- 0L


  for (j in 1:20){
    ## use last
    d2x <- zlist$diToXX[ i + 1L ]
    zlist$XXN[ d2x+1L ] <-   zlist$XXN[ d2x+1L ] - 1.0
    zlist$XXN1  <- if (zlist$XXN[ d2x + 1L] == 0L) 1L else 0L
    zlist <- call_updateXX(length(zlist$XXN)-1L, i, zlist)  
    ## discard last
    d2x <- zlist$diToXX[ i + 1L ]
    zlist$XXN[ d2x+1L ] <-   zlist$XXN[ d2x+1L ] - 1.0
    zlist$XXN1  <- if (zlist$XXN[ d2x + 1L] == 0L) 1L else 0L
    zlist <- call_updateXX(1L, i, zlist)
  }

#+end_src



** auxGibbs

#+begin_src cpp :noweb yes :main no :tangle nobuild/test-auxGibbs.cpp
  <<arma-headers>>
  <<rdirich>>
  <<logprob_Rplus>>
  <<logprobMulti>>
  <<newIndex>>
  <<rlamGivenR>>
  <<updateXX>>
  <<auxGibbs>>
#+end_src

#+begin_src R :noweb yes :session *R:cellTypeCompositions*
Rcpp::sourceCpp("nobuild/test-auxGibbs.cpp")
#+end_src

#+RESULTS:

The results here seems plausible. But keep an eye on the lambda
values for small r.


#+begin_src R :noweb yes :session *R:cellTypeCompositions*
  source("R/gibbsDPP.R")
  load("~/projects/bushman/WAS/derep-11-17/wttabs.etc.RData")
  wtab <- wttabs[[11]]
  om <- with(param.list[[11]],diag(upsilon)%*%omega%*%diag(psi))

  tmp <- gibbsDPP(wtab,om,verbose=1L)
  str(tmp)

  tmp <- gibbsDPP(wtab,om,alphaEta=1.0,alphaLambda=0.5, verbose=1L)

  with(tmp,cbind(lambda,lambdaN)[order(lambda),])
#+end_src

#+RESULTS:




** rmultnm

#+begin_src R :noweb yes  :session *R:cellTypeCompositions*
  Rcpp::sourceCpp(code='
  <<arma-headers>>
  <<rmultnm>>
  // [[Rcpp::export]]
  ivec call_rmultnm(int n, NumericVector prob, int k){
  ivec rn(n);
  rmultnm(n, REAL(prob), k, &rn[0]);
    return rn;}
    ')
#+end_src

#+RESULTS:

#+begin_src R :noweb yes
  ## test here
  set.seed(123)
  cr <- replicate(1000,call_rmultnm(5L,1:5,5))
  set.seed(123)
  rr <- replicate(1000, rmultinom(1,5,1:5))
  if (all(cr==rr)) "PASS" else "FAIL"
#+end_src

** sampleParms

#+begin_src cpp :noweb yes :tangle nobuild/sampleParms.cpp
    <<arma-headers>>
  <<rmultnm>>
  
#+end_src

#+begin_src R :noweb yes :session *R:cellTypeCompositions*

#+end_src

* tuneup

#+name: sampleParms
#+begin_src cpp
  // assume di, dataTo[ Eta | Lambda ] are zero based indexes

  // [[Rcpp::export]]
  List sampleParms(
		   arma::imat& tab,
		   arma::ivec& di,
		   arma::mat& om,
		   arma::ivec dataToEta,
		   arma::ivec dataToLambda,
		   arma::mat eta, int etaM, 
		   arma::rowvec lambda, arma::vec& lambdaN, int lambdaM,
		   double dprior,
		   double dpriorLambda, int verbose=0L){
    if (verbose>1L) Rprintf("starting....\n");
    int J = om.n_rows;
    vec omsum = sum(om, 1L);
    ivec r = sum( tab, 1L); // rowSums
    int ndat = di.size();
      if (verbose>1L) Rprintf("inits\n");
  // eta.by.ct
    imat eta_by_ct( etaM, J , fill::zeros );
  // eta.by.lambda.by.r
    imat eta_by_lambda_by_r(etaM, lambdaM, fill::zeros );

    for (int i = 0L; i<ndat; i++){
      eta_by_ct.row( dataToEta(i)) = eta_by_ct.row( dataToEta(i) ) + tab.row( di(i) );
      eta_by_lambda_by_r( dataToEta(i) , dataToLambda(i) ) += r( di(i) );
    }
    if (verbose>1L) Rprintf("eta.by.lambda.by.r\n");

  // rho.vec 
  // rho.tilde 

    vec rhocomp = 1.0 - vectorise(trans( omsum ) * eta.head_cols( etaM ));
    mat rhoTilde = 1.0 - ( rhocomp * lambda.head( lambdaM) );
    if (verbose>1L) Rprintf("rhoTilde\n");
  // R_minus_r

    mat R_minus_r( etaM, lambdaM );
    for (int i = 0L; i<etaM; i++)
      for (int j = 0L; j<lambdaM; j++)
	R_minus_r(i, j) = (eta_by_lambda_by_r(i,j) == 0L) ? 0.0 :
	  Rf_rnbinom(( double) eta_by_lambda_by_r(i,j), rhoTilde(i,j));
    if (verbose>1L) Rprintf("R_minus_r\n");

  // R_by_eta
    vec R_by_eta = sum(R_minus_r,1L);
    if (verbose>1L) Rprintf("R_by_eta\n");
  // dropped
    imat dropped(J, etaM, fill::zeros);

    for (int i = 0L; i<etaM; i++)
      if (R_by_eta(i) != 0.0){
	vec eta_out = eta.col(i) % (1.0 - omsum);
	rmultnm(R_by_eta(i),eta_out.memptr(),J,dropped.colptr(i));
      }
      if (verbose>1L) Rprintf("dropped\n");

  // R
    mat R = R_minus_r + eta_by_lambda_by_r;
      if (verbose>1L) Rprintf("R\n");
  // eta.by.ct.all
    imat eta_by_ct_all = eta_by_ct + dropped.t();
      if (verbose>1L) Rprintf("eta_by_ct_all\n");
  // new.eta
    for (int i = 0L; i< etaM; i++)
      for (int j = 0L; j < J; j++)
	eta(j,i) = Rf_rgamma((double) eta_by_ct_all(i,j) + dprior, 1); 
    if (verbose>1L) Rprintf("gammas\n");
    eta.head_cols(etaM).each_row() /=  sum( eta.head_cols(etaM), 0L); 
    if (verbose>1L) Rprintf("new_eta\n");

  // rho.vec 
    rhocomp = 1.0 - vectorise(trans(omsum) * eta.head_cols(etaM));
  // rho.tilde
    rhoTilde = 1.0 - ( rhocomp * lambda.head( lambdaM) );
    if (verbose>1L) Rprintf("rhoTilde\n");

    // R_minus_r

    for (int i = 0L; i<etaM; i++)
      for (int j = 0L; j<lambdaM; j++)
	R_minus_r(i, j) = (eta_by_lambda_by_r(i,j) == 0L) ? 0.0 :
	  Rf_rnbinom(( double) eta_by_lambda_by_r(i,j), rhoTilde(i,j));

  // R

    R = R_minus_r + eta_by_lambda_by_r;
  // 
  // update lambda

    for (int i = 0L; i<lambdaM; i++)
      lambda(i) = Rf_rbeta(dpriorLambda + sum(R.col(i)), 1.0 + lambdaN(i));

  //

    return List::create(_["eta"] = eta,
			_["lambda"] = lambda);

  }

#+end_src
